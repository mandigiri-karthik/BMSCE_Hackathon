from flask import Flask, render_template, request, send_file, jsonify
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.pipeline import make_pipeline
from fpdf import FPDF
from datetime import datetime
import re

app = Flask(__name__)

# Load the dataset for the first model
df = pd.read_excel("Healthcare_Disease_Treatment_Data_500.xlsx")
X = df['Symptoms']
y_disease = df['Disease']
medicines = df[['Medicine Suggested', 'Medicinal Composition', 'Treatment Description']]

# Split the dataset into train and test sets
X_train, X_test, y_train, y_test, med_train, med_test = train_test_split(X, y_disease, medicines, test_size=0.2, random_state=42)

# Create a pipeline for TF-IDF vectorization and classification
pipeline = make_pipeline(
    TfidfVectorizer(),
    RandomForestClassifier()
)

# Train the model
pipeline.fit(X_train, y_train)

# Load the chatbot dataset
chatbot_data = pd.read_csv("dataset.csv")

# Clean the chatbot dataset
chatbot_data_cleaned = chatbot_data.applymap(lambda x: x.strip().lower() if isinstance(x, str) else x)

# Symptom-based filtering logic
def filter_diseases(symptoms):
    cold_related = ['cold', 'cough', 'sore throat']
    neurological_related = ['headache', 'migraine']
    
    if any(symptom in symptoms.lower() for symptom in cold_related):
        return df[df['Disease'].isin(['Common Cold', 'Flu', 'Bronchitis'])]
    elif any(symptom in symptoms.lower() for symptom in neurological_related):
        return df[df['Disease'].isin(['Migraine', 'Cluster Headache', 'Tension Headache'])]
    
    return df

# Define a function to make predictions based on user input
def predict_medicine(symptoms):
    filtered_df = filter_diseases(symptoms)
    if filtered_df.empty:
        return None
    pipeline.fit(filtered_df['Symptoms'], filtered_df['Disease'])
    predicted_disease = pipeline.predict([symptoms])[0]
    medicine_row = filtered_df[filtered_df['Disease'] == predicted_disease].iloc[0]
    return {
        'Disease': predicted_disease,
        'Medicine Suggested': medicine_row['Medicine Suggested'],
        'Medicinal Composition': medicine_row['Medicinal Composition'],
        'Treatment Description': medicine_row['Treatment Description']
    }

# Function to generate PDF with the output
def generate_fancy_pdf(symptoms, recommendation, patient_name="Patient", patient_age="N/A"):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font('Arial', 'B', 24)
    pdf.cell(200, 10, 'Medical Report', ln=True, align='C')
    pdf.ln(10)
    pdf.set_font('Arial', 'I', 12)
    pdf.cell(0, 10, 'Date: ' + datetime.now().strftime("%Y-%m-%d"), ln=True, align='R')
    pdf.cell(200, 10, f'Patient Name: {patient_name}', ln=True)
    pdf.cell(200, 10, f'Age: {patient_age}', ln=True)
    pdf.ln(10)
    pdf.set_font('Arial', 'B', 16)
    pdf.cell(200, 10, 'Symptoms Provided:', ln=True)
    pdf.set_font('Arial', '', 12)
    pdf.multi_cell(0, 10, symptoms)
    pdf.ln(10)
    pdf.set_font('Arial', 'B', 16)
    pdf.cell(200, 10, 'Diagnosis:', ln=True)
    pdf.set_font('Arial', '', 12)
    pdf.cell(200, 10, 'Predicted Disease: ' + recommendation['Disease'], ln=True)
    pdf.cell(200, 10, 'Medicine Suggested: ' + recommendation['Medicine Suggested'], ln=True)
    pdf.cell(200, 10, 'Medicinal Composition: ' + recommendation['Medicinal Composition'], ln=True)
    pdf.multi_cell(0, 10, 'Treatment Description: ' + recommendation['Treatment Description'])
    pdf.ln(10)
    pdf.set_font('Arial', 'I', 10)
    disclaimer = ("Disclaimer: This report is generated by an AI system and is intended for informational purposes only. "
                  "It is not a substitute for professional medical advice, diagnosis, or treatment.")
    pdf.multi_cell(0, 10, disclaimer, align='L')
    pdf.set_y(-15)
    pdf.set_font('Arial', 'I', 8)
    pdf.cell(0, 10, f'Page {pdf.page_no()}', 0, 0, 'C')

    # Save the PDF to a file
    file_name = "Predicted_Treatment.pdf"
    pdf.output(file_name)
    return file_name

@app.route('/')
def home():
    return render_template('home.html')

@app.route('/about')
def about():
    return render_template('about.html')

@app.route('/courses')
def courses():
    return render_template('courses.html')

@app.route('/virtualclass')
def virtual_class():
    return render_template('virtualclass.html')

@app.route('/teachers')
def teachers():
    return render_template('teachers.html')

@app.route('/contact')
def contact():
    return render_template('contact.html')

@app.route('/profile')
def profile():
    return render_template('profile.html')

@app.route('/generate_report', methods=['POST'])
def generate_report():
    symptoms = request.form['symptoms']
    patient_name = request.form['patient_name']
    patient_age = request.form['patient_age']

    recommendation = predict_medicine(symptoms)

    if recommendation is None:
        return "No recommendation found for the provided symptoms.", 404

    pdf_file = generate_fancy_pdf(symptoms, recommendation, patient_name, patient_age)
    return send_file(pdf_file, as_attachment=True)

# Load the second dataset and prepare the model
data = pd.read_excel("medicinalplantsdataset.xlsx")
X = data['symptoms']
y = data[['Hindi Name', 'English Name', 'Botanical Name']]
model = make_pipeline(TfidfVectorizer(), RandomForestClassifier())
model.fit(X, y['Hindi Name'])

@app.route('/predict', methods=['POST'])
def predict():
    symptoms = request.json['symptoms']
    plant_name_hindi = model.predict([symptoms])[0]

    # Get the plant details
    plant_details = data[data['Hindi Name'] == plant_name_hindi].iloc[0]
    
    return jsonify({
        'Hindi Name': plant_details['Hindi Name'],
        'English Name': plant_details['English Name'],
        'Botanical Name': plant_details['Botanical Name'],
        'Remedy': plant_details['Remedy']
    })

# Function to preprocess and extract keywords from user input
def preprocess_input(user_input):
    words_to_ignore = ['what', 'are', 'the', 'symptoms', 'of', 'i', 'have', 'please', 'tell', 'me']
    user_input = user_input.lower()
    user_input = re.sub(r'[^a-zA-Z,\s]', '', user_input)
    words = [word.strip() for word in user_input.split() if word not in words_to_ignore]
    return words

# Function to find disease based on symptoms (fuzzy matching)
def find_disease_based_on_symptoms(symptoms):
    for index, row in chatbot_data_cleaned.iterrows():
        row_symptoms = row[1:].dropna().tolist()
        if all(any(symptom in s for s in row_symptoms) for symptom in symptoms):
            return row['Disease'].capitalize()
    return "No matching disease found."

# Route to handle chatbot requests
@app.route('/chat', methods=['POST'])
def chat():
    user_input = request.json['input']
    keywords = preprocess_input(user_input)
    
    if "symptom" in user_input.lower():
        disease = ' '.join(keywords)
        symptoms = get_symptoms_for_disease(disease)
        if symptoms == "Disease not found.":
            return jsonify({"response": "Disease not found."})
        else:
            return jsonify({"response": f"Symptoms of {disease.capitalize()}: {', '.join(symptoms)}"})
    
    elif "have" in user_input.lower():
        symptoms = keywords
        disease = find_disease_based_on_symptoms(symptoms)
        return jsonify({"response": f"You might have: {disease}"})
    
    else:
        return jsonify({"response": "I'm sorry, I didn't understand that. Please try again."})

# Function to get symptoms for a disease
def get_symptoms_for_disease(disease):
    row = chatbot_data_cleaned[chatbot_data_cleaned['Disease'].str.contains(disease, na=False, case=False)]
    if row.empty:
        return "Disease not found."
    else:
        symptoms = row.iloc[0, 1:].dropna().tolist()
        return symptoms

if __name__ == '__main__':
    app.run(debug=True)
